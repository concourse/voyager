// Code generated by counterfeiter. DO NOT EDIT.
package voyagerfakes

import (
	"database/sql"
	"sync"

	"github.com/concourse/voyager"
)

type FakeSchemaAdapter struct {
	CurrentVersionStub        func(*sql.DB) (int, error)
	currentVersionMutex       sync.RWMutex
	currentVersionArgsForCall []struct {
		arg1 *sql.DB
	}
	currentVersionReturns struct {
		result1 int
		result2 error
	}
	currentVersionReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	MigrateFromOldSchemaStub        func(*sql.DB, int) (int, error)
	migrateFromOldSchemaMutex       sync.RWMutex
	migrateFromOldSchemaArgsForCall []struct {
		arg1 *sql.DB
		arg2 int
	}
	migrateFromOldSchemaReturns struct {
		result1 int
		result2 error
	}
	migrateFromOldSchemaReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	MigrateToOldSchemaStub        func(*sql.DB, int) error
	migrateToOldSchemaMutex       sync.RWMutex
	migrateToOldSchemaArgsForCall []struct {
		arg1 *sql.DB
		arg2 int
	}
	migrateToOldSchemaReturns struct {
		result1 error
	}
	migrateToOldSchemaReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSchemaAdapter) CurrentVersion(arg1 *sql.DB) (int, error) {
	fake.currentVersionMutex.Lock()
	ret, specificReturn := fake.currentVersionReturnsOnCall[len(fake.currentVersionArgsForCall)]
	fake.currentVersionArgsForCall = append(fake.currentVersionArgsForCall, struct {
		arg1 *sql.DB
	}{arg1})
	fake.recordInvocation("CurrentVersion", []interface{}{arg1})
	fake.currentVersionMutex.Unlock()
	if fake.CurrentVersionStub != nil {
		return fake.CurrentVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSchemaAdapter) CurrentVersionCallCount() int {
	fake.currentVersionMutex.RLock()
	defer fake.currentVersionMutex.RUnlock()
	return len(fake.currentVersionArgsForCall)
}

func (fake *FakeSchemaAdapter) CurrentVersionCalls(stub func(*sql.DB) (int, error)) {
	fake.currentVersionMutex.Lock()
	defer fake.currentVersionMutex.Unlock()
	fake.CurrentVersionStub = stub
}

func (fake *FakeSchemaAdapter) CurrentVersionArgsForCall(i int) *sql.DB {
	fake.currentVersionMutex.RLock()
	defer fake.currentVersionMutex.RUnlock()
	argsForCall := fake.currentVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSchemaAdapter) CurrentVersionReturns(result1 int, result2 error) {
	fake.currentVersionMutex.Lock()
	defer fake.currentVersionMutex.Unlock()
	fake.CurrentVersionStub = nil
	fake.currentVersionReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) CurrentVersionReturnsOnCall(i int, result1 int, result2 error) {
	fake.currentVersionMutex.Lock()
	defer fake.currentVersionMutex.Unlock()
	fake.CurrentVersionStub = nil
	if fake.currentVersionReturnsOnCall == nil {
		fake.currentVersionReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.currentVersionReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchema(arg1 *sql.DB, arg2 int) (int, error) {
	fake.migrateFromOldSchemaMutex.Lock()
	ret, specificReturn := fake.migrateFromOldSchemaReturnsOnCall[len(fake.migrateFromOldSchemaArgsForCall)]
	fake.migrateFromOldSchemaArgsForCall = append(fake.migrateFromOldSchemaArgsForCall, struct {
		arg1 *sql.DB
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("MigrateFromOldSchema", []interface{}{arg1, arg2})
	fake.migrateFromOldSchemaMutex.Unlock()
	if fake.MigrateFromOldSchemaStub != nil {
		return fake.MigrateFromOldSchemaStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.migrateFromOldSchemaReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaCallCount() int {
	fake.migrateFromOldSchemaMutex.RLock()
	defer fake.migrateFromOldSchemaMutex.RUnlock()
	return len(fake.migrateFromOldSchemaArgsForCall)
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaCalls(stub func(*sql.DB, int) (int, error)) {
	fake.migrateFromOldSchemaMutex.Lock()
	defer fake.migrateFromOldSchemaMutex.Unlock()
	fake.MigrateFromOldSchemaStub = stub
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaArgsForCall(i int) (*sql.DB, int) {
	fake.migrateFromOldSchemaMutex.RLock()
	defer fake.migrateFromOldSchemaMutex.RUnlock()
	argsForCall := fake.migrateFromOldSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaReturns(result1 int, result2 error) {
	fake.migrateFromOldSchemaMutex.Lock()
	defer fake.migrateFromOldSchemaMutex.Unlock()
	fake.MigrateFromOldSchemaStub = nil
	fake.migrateFromOldSchemaReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaReturnsOnCall(i int, result1 int, result2 error) {
	fake.migrateFromOldSchemaMutex.Lock()
	defer fake.migrateFromOldSchemaMutex.Unlock()
	fake.MigrateFromOldSchemaStub = nil
	if fake.migrateFromOldSchemaReturnsOnCall == nil {
		fake.migrateFromOldSchemaReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.migrateFromOldSchemaReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) MigrateToOldSchema(arg1 *sql.DB, arg2 int) error {
	fake.migrateToOldSchemaMutex.Lock()
	ret, specificReturn := fake.migrateToOldSchemaReturnsOnCall[len(fake.migrateToOldSchemaArgsForCall)]
	fake.migrateToOldSchemaArgsForCall = append(fake.migrateToOldSchemaArgsForCall, struct {
		arg1 *sql.DB
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("MigrateToOldSchema", []interface{}{arg1, arg2})
	fake.migrateToOldSchemaMutex.Unlock()
	if fake.MigrateToOldSchemaStub != nil {
		return fake.MigrateToOldSchemaStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.migrateToOldSchemaReturns
	return fakeReturns.result1
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaCallCount() int {
	fake.migrateToOldSchemaMutex.RLock()
	defer fake.migrateToOldSchemaMutex.RUnlock()
	return len(fake.migrateToOldSchemaArgsForCall)
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaCalls(stub func(*sql.DB, int) error) {
	fake.migrateToOldSchemaMutex.Lock()
	defer fake.migrateToOldSchemaMutex.Unlock()
	fake.MigrateToOldSchemaStub = stub
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaArgsForCall(i int) (*sql.DB, int) {
	fake.migrateToOldSchemaMutex.RLock()
	defer fake.migrateToOldSchemaMutex.RUnlock()
	argsForCall := fake.migrateToOldSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaReturns(result1 error) {
	fake.migrateToOldSchemaMutex.Lock()
	defer fake.migrateToOldSchemaMutex.Unlock()
	fake.MigrateToOldSchemaStub = nil
	fake.migrateToOldSchemaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaReturnsOnCall(i int, result1 error) {
	fake.migrateToOldSchemaMutex.Lock()
	defer fake.migrateToOldSchemaMutex.Unlock()
	fake.MigrateToOldSchemaStub = nil
	if fake.migrateToOldSchemaReturnsOnCall == nil {
		fake.migrateToOldSchemaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.migrateToOldSchemaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchemaAdapter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.currentVersionMutex.RLock()
	defer fake.currentVersionMutex.RUnlock()
	fake.migrateFromOldSchemaMutex.RLock()
	defer fake.migrateFromOldSchemaMutex.RUnlock()
	fake.migrateToOldSchemaMutex.RLock()
	defer fake.migrateToOldSchemaMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSchemaAdapter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ voyager.SchemaAdapter = new(FakeSchemaAdapter)
