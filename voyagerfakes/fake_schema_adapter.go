// Code generated by counterfeiter. DO NOT EDIT.
package voyagerfakes

import (
	"database/sql"
	"sync"

	"github.com/concourse/voyager"
)

type FakeSchemaAdapter struct {
	MigrateFromOldSchemaStub        func(*sql.DB, int) (int, error)
	migrateFromOldSchemaMutex       sync.RWMutex
	migrateFromOldSchemaArgsForCall []struct {
		arg1 *sql.DB
		arg2 int
	}
	migrateFromOldSchemaReturns struct {
		result1 int
		result2 error
	}
	migrateFromOldSchemaReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	MigrateToOldSchemaStub        func(*sql.DB, int) error
	migrateToOldSchemaMutex       sync.RWMutex
	migrateToOldSchemaArgsForCall []struct {
		arg1 *sql.DB
		arg2 int
	}
	migrateToOldSchemaReturns struct {
		result1 error
	}
	migrateToOldSchemaReturnsOnCall map[int]struct {
		result1 error
	}
	OldSchemaLastVersionStub        func() int
	oldSchemaLastVersionMutex       sync.RWMutex
	oldSchemaLastVersionArgsForCall []struct {
	}
	oldSchemaLastVersionReturns struct {
		result1 int
	}
	oldSchemaLastVersionReturnsOnCall map[int]struct {
		result1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchema(arg1 *sql.DB, arg2 int) (int, error) {
	fake.migrateFromOldSchemaMutex.Lock()
	ret, specificReturn := fake.migrateFromOldSchemaReturnsOnCall[len(fake.migrateFromOldSchemaArgsForCall)]
	fake.migrateFromOldSchemaArgsForCall = append(fake.migrateFromOldSchemaArgsForCall, struct {
		arg1 *sql.DB
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("MigrateFromOldSchema", []interface{}{arg1, arg2})
	fake.migrateFromOldSchemaMutex.Unlock()
	if fake.MigrateFromOldSchemaStub != nil {
		return fake.MigrateFromOldSchemaStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.migrateFromOldSchemaReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaCallCount() int {
	fake.migrateFromOldSchemaMutex.RLock()
	defer fake.migrateFromOldSchemaMutex.RUnlock()
	return len(fake.migrateFromOldSchemaArgsForCall)
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaCalls(stub func(*sql.DB, int) (int, error)) {
	fake.migrateFromOldSchemaMutex.Lock()
	defer fake.migrateFromOldSchemaMutex.Unlock()
	fake.MigrateFromOldSchemaStub = stub
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaArgsForCall(i int) (*sql.DB, int) {
	fake.migrateFromOldSchemaMutex.RLock()
	defer fake.migrateFromOldSchemaMutex.RUnlock()
	argsForCall := fake.migrateFromOldSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaReturns(result1 int, result2 error) {
	fake.migrateFromOldSchemaMutex.Lock()
	defer fake.migrateFromOldSchemaMutex.Unlock()
	fake.MigrateFromOldSchemaStub = nil
	fake.migrateFromOldSchemaReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) MigrateFromOldSchemaReturnsOnCall(i int, result1 int, result2 error) {
	fake.migrateFromOldSchemaMutex.Lock()
	defer fake.migrateFromOldSchemaMutex.Unlock()
	fake.MigrateFromOldSchemaStub = nil
	if fake.migrateFromOldSchemaReturnsOnCall == nil {
		fake.migrateFromOldSchemaReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.migrateFromOldSchemaReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) MigrateToOldSchema(arg1 *sql.DB, arg2 int) error {
	fake.migrateToOldSchemaMutex.Lock()
	ret, specificReturn := fake.migrateToOldSchemaReturnsOnCall[len(fake.migrateToOldSchemaArgsForCall)]
	fake.migrateToOldSchemaArgsForCall = append(fake.migrateToOldSchemaArgsForCall, struct {
		arg1 *sql.DB
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("MigrateToOldSchema", []interface{}{arg1, arg2})
	fake.migrateToOldSchemaMutex.Unlock()
	if fake.MigrateToOldSchemaStub != nil {
		return fake.MigrateToOldSchemaStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.migrateToOldSchemaReturns
	return fakeReturns.result1
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaCallCount() int {
	fake.migrateToOldSchemaMutex.RLock()
	defer fake.migrateToOldSchemaMutex.RUnlock()
	return len(fake.migrateToOldSchemaArgsForCall)
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaCalls(stub func(*sql.DB, int) error) {
	fake.migrateToOldSchemaMutex.Lock()
	defer fake.migrateToOldSchemaMutex.Unlock()
	fake.MigrateToOldSchemaStub = stub
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaArgsForCall(i int) (*sql.DB, int) {
	fake.migrateToOldSchemaMutex.RLock()
	defer fake.migrateToOldSchemaMutex.RUnlock()
	argsForCall := fake.migrateToOldSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaReturns(result1 error) {
	fake.migrateToOldSchemaMutex.Lock()
	defer fake.migrateToOldSchemaMutex.Unlock()
	fake.MigrateToOldSchemaStub = nil
	fake.migrateToOldSchemaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchemaAdapter) MigrateToOldSchemaReturnsOnCall(i int, result1 error) {
	fake.migrateToOldSchemaMutex.Lock()
	defer fake.migrateToOldSchemaMutex.Unlock()
	fake.MigrateToOldSchemaStub = nil
	if fake.migrateToOldSchemaReturnsOnCall == nil {
		fake.migrateToOldSchemaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.migrateToOldSchemaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchemaAdapter) OldSchemaLastVersion() int {
	fake.oldSchemaLastVersionMutex.Lock()
	ret, specificReturn := fake.oldSchemaLastVersionReturnsOnCall[len(fake.oldSchemaLastVersionArgsForCall)]
	fake.oldSchemaLastVersionArgsForCall = append(fake.oldSchemaLastVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("OldSchemaLastVersion", []interface{}{})
	fake.oldSchemaLastVersionMutex.Unlock()
	if fake.OldSchemaLastVersionStub != nil {
		return fake.OldSchemaLastVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.oldSchemaLastVersionReturns
	return fakeReturns.result1
}

func (fake *FakeSchemaAdapter) OldSchemaLastVersionCallCount() int {
	fake.oldSchemaLastVersionMutex.RLock()
	defer fake.oldSchemaLastVersionMutex.RUnlock()
	return len(fake.oldSchemaLastVersionArgsForCall)
}

func (fake *FakeSchemaAdapter) OldSchemaLastVersionCalls(stub func() int) {
	fake.oldSchemaLastVersionMutex.Lock()
	defer fake.oldSchemaLastVersionMutex.Unlock()
	fake.OldSchemaLastVersionStub = stub
}

func (fake *FakeSchemaAdapter) OldSchemaLastVersionReturns(result1 int) {
	fake.oldSchemaLastVersionMutex.Lock()
	defer fake.oldSchemaLastVersionMutex.Unlock()
	fake.OldSchemaLastVersionStub = nil
	fake.oldSchemaLastVersionReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeSchemaAdapter) OldSchemaLastVersionReturnsOnCall(i int, result1 int) {
	fake.oldSchemaLastVersionMutex.Lock()
	defer fake.oldSchemaLastVersionMutex.Unlock()
	fake.OldSchemaLastVersionStub = nil
	if fake.oldSchemaLastVersionReturnsOnCall == nil {
		fake.oldSchemaLastVersionReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.oldSchemaLastVersionReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeSchemaAdapter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.migrateFromOldSchemaMutex.RLock()
	defer fake.migrateFromOldSchemaMutex.RUnlock()
	fake.migrateToOldSchemaMutex.RLock()
	defer fake.migrateToOldSchemaMutex.RUnlock()
	fake.oldSchemaLastVersionMutex.RLock()
	defer fake.oldSchemaLastVersionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSchemaAdapter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ voyager.SchemaAdapter = new(FakeSchemaAdapter)
