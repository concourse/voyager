// Code generated by counterfeiter. DO NOT EDIT.
package voyagerfakes

import (
	"database/sql"
	"sync"

	"github.com/concourse/voyager"
)

type FakeSchemaAdapter struct {
	ConvertFromOldSchemaStub        func(*sql.DB, int) (int, error)
	convertFromOldSchemaMutex       sync.RWMutex
	convertFromOldSchemaArgsForCall []struct {
		arg1 *sql.DB
		arg2 int
	}
	convertFromOldSchemaReturns struct {
		result1 int
		result2 error
	}
	convertFromOldSchemaReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ConvertToOldSchemaStub        func(*sql.DB, int) error
	convertToOldSchemaMutex       sync.RWMutex
	convertToOldSchemaArgsForCall []struct {
		arg1 *sql.DB
		arg2 int
	}
	convertToOldSchemaReturns struct {
		result1 error
	}
	convertToOldSchemaReturnsOnCall map[int]struct {
		result1 error
	}
	CurrentVersionStub        func(*sql.DB) (int, error)
	currentVersionMutex       sync.RWMutex
	currentVersionArgsForCall []struct {
		arg1 *sql.DB
	}
	currentVersionReturns struct {
		result1 int
		result2 error
	}
	currentVersionReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSchemaAdapter) ConvertFromOldSchema(arg1 *sql.DB, arg2 int) (int, error) {
	fake.convertFromOldSchemaMutex.Lock()
	ret, specificReturn := fake.convertFromOldSchemaReturnsOnCall[len(fake.convertFromOldSchemaArgsForCall)]
	fake.convertFromOldSchemaArgsForCall = append(fake.convertFromOldSchemaArgsForCall, struct {
		arg1 *sql.DB
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("ConvertFromOldSchema", []interface{}{arg1, arg2})
	fake.convertFromOldSchemaMutex.Unlock()
	if fake.ConvertFromOldSchemaStub != nil {
		return fake.ConvertFromOldSchemaStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.convertFromOldSchemaReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSchemaAdapter) ConvertFromOldSchemaCallCount() int {
	fake.convertFromOldSchemaMutex.RLock()
	defer fake.convertFromOldSchemaMutex.RUnlock()
	return len(fake.convertFromOldSchemaArgsForCall)
}

func (fake *FakeSchemaAdapter) ConvertFromOldSchemaCalls(stub func(*sql.DB, int) (int, error)) {
	fake.convertFromOldSchemaMutex.Lock()
	defer fake.convertFromOldSchemaMutex.Unlock()
	fake.ConvertFromOldSchemaStub = stub
}

func (fake *FakeSchemaAdapter) ConvertFromOldSchemaArgsForCall(i int) (*sql.DB, int) {
	fake.convertFromOldSchemaMutex.RLock()
	defer fake.convertFromOldSchemaMutex.RUnlock()
	argsForCall := fake.convertFromOldSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSchemaAdapter) ConvertFromOldSchemaReturns(result1 int, result2 error) {
	fake.convertFromOldSchemaMutex.Lock()
	defer fake.convertFromOldSchemaMutex.Unlock()
	fake.ConvertFromOldSchemaStub = nil
	fake.convertFromOldSchemaReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) ConvertFromOldSchemaReturnsOnCall(i int, result1 int, result2 error) {
	fake.convertFromOldSchemaMutex.Lock()
	defer fake.convertFromOldSchemaMutex.Unlock()
	fake.ConvertFromOldSchemaStub = nil
	if fake.convertFromOldSchemaReturnsOnCall == nil {
		fake.convertFromOldSchemaReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.convertFromOldSchemaReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) ConvertToOldSchema(arg1 *sql.DB, arg2 int) error {
	fake.convertToOldSchemaMutex.Lock()
	ret, specificReturn := fake.convertToOldSchemaReturnsOnCall[len(fake.convertToOldSchemaArgsForCall)]
	fake.convertToOldSchemaArgsForCall = append(fake.convertToOldSchemaArgsForCall, struct {
		arg1 *sql.DB
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("ConvertToOldSchema", []interface{}{arg1, arg2})
	fake.convertToOldSchemaMutex.Unlock()
	if fake.ConvertToOldSchemaStub != nil {
		return fake.ConvertToOldSchemaStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.convertToOldSchemaReturns
	return fakeReturns.result1
}

func (fake *FakeSchemaAdapter) ConvertToOldSchemaCallCount() int {
	fake.convertToOldSchemaMutex.RLock()
	defer fake.convertToOldSchemaMutex.RUnlock()
	return len(fake.convertToOldSchemaArgsForCall)
}

func (fake *FakeSchemaAdapter) ConvertToOldSchemaCalls(stub func(*sql.DB, int) error) {
	fake.convertToOldSchemaMutex.Lock()
	defer fake.convertToOldSchemaMutex.Unlock()
	fake.ConvertToOldSchemaStub = stub
}

func (fake *FakeSchemaAdapter) ConvertToOldSchemaArgsForCall(i int) (*sql.DB, int) {
	fake.convertToOldSchemaMutex.RLock()
	defer fake.convertToOldSchemaMutex.RUnlock()
	argsForCall := fake.convertToOldSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSchemaAdapter) ConvertToOldSchemaReturns(result1 error) {
	fake.convertToOldSchemaMutex.Lock()
	defer fake.convertToOldSchemaMutex.Unlock()
	fake.ConvertToOldSchemaStub = nil
	fake.convertToOldSchemaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchemaAdapter) ConvertToOldSchemaReturnsOnCall(i int, result1 error) {
	fake.convertToOldSchemaMutex.Lock()
	defer fake.convertToOldSchemaMutex.Unlock()
	fake.ConvertToOldSchemaStub = nil
	if fake.convertToOldSchemaReturnsOnCall == nil {
		fake.convertToOldSchemaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.convertToOldSchemaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSchemaAdapter) CurrentVersion(arg1 *sql.DB) (int, error) {
	fake.currentVersionMutex.Lock()
	ret, specificReturn := fake.currentVersionReturnsOnCall[len(fake.currentVersionArgsForCall)]
	fake.currentVersionArgsForCall = append(fake.currentVersionArgsForCall, struct {
		arg1 *sql.DB
	}{arg1})
	fake.recordInvocation("CurrentVersion", []interface{}{arg1})
	fake.currentVersionMutex.Unlock()
	if fake.CurrentVersionStub != nil {
		return fake.CurrentVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.currentVersionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSchemaAdapter) CurrentVersionCallCount() int {
	fake.currentVersionMutex.RLock()
	defer fake.currentVersionMutex.RUnlock()
	return len(fake.currentVersionArgsForCall)
}

func (fake *FakeSchemaAdapter) CurrentVersionCalls(stub func(*sql.DB) (int, error)) {
	fake.currentVersionMutex.Lock()
	defer fake.currentVersionMutex.Unlock()
	fake.CurrentVersionStub = stub
}

func (fake *FakeSchemaAdapter) CurrentVersionArgsForCall(i int) *sql.DB {
	fake.currentVersionMutex.RLock()
	defer fake.currentVersionMutex.RUnlock()
	argsForCall := fake.currentVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSchemaAdapter) CurrentVersionReturns(result1 int, result2 error) {
	fake.currentVersionMutex.Lock()
	defer fake.currentVersionMutex.Unlock()
	fake.CurrentVersionStub = nil
	fake.currentVersionReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) CurrentVersionReturnsOnCall(i int, result1 int, result2 error) {
	fake.currentVersionMutex.Lock()
	defer fake.currentVersionMutex.Unlock()
	fake.CurrentVersionStub = nil
	if fake.currentVersionReturnsOnCall == nil {
		fake.currentVersionReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.currentVersionReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSchemaAdapter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.convertFromOldSchemaMutex.RLock()
	defer fake.convertFromOldSchemaMutex.RUnlock()
	fake.convertToOldSchemaMutex.RLock()
	defer fake.convertToOldSchemaMutex.RUnlock()
	fake.currentVersionMutex.RLock()
	defer fake.currentVersionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSchemaAdapter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ voyager.SchemaAdapter = new(FakeSchemaAdapter)
